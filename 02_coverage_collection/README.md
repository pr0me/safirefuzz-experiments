# Coverage Collection

With the setup described in the following, we can collect coverage information, i.e., which basic blocks have been reached during a fuzzing campaign, from a fuzzing queue.

After running a fuzzing campaign for a target, we replay all found inputs of the fuzzing queue to collect coverage information in a comparable way.  
Except for Fuzzware, because here the format of inputs found during fuzzing diverges, we use HALucinator with the [Unicorn](https://github.com/unicorn-engine/unicorn) emulator for replaying. 

## Using the Example
We provide an example queue of inputs found during fuzzing, which led to new paths/coverage in the firmware.  
The inputs are generated by fuzzing the WYCINWYC target for 15 seconds.

## Generating your own Queue
Alternatively, you can collect coverage information for your own campaigns.  
As described in [`../01_fuzzing`](../fuzzing/README.md), start a fuzzing campaign for a target and framework of your choice.

For `SAFIREFUZZ` and `hal-fuzz_libafl`, you will find generated inputs in `./queue` and `./out` respectively.  
First, cleanup lock files and stat the inputs:
```
cd ./queue
rm ./.*
for f in ./*                                   
do                  
stat $f >> stat.log
done
```
As libAFL does not save timestamps when a new interesting input is found (like legacy AFL does in `./output/plot_data`), we use stat information to generate time-relative coverage information in our scripts.

For HALucinator, AFL creates an `./output` directory for the specified target containing the queue, e.g., `hal-fuzz/tests/atmel_6lowpan_udp_rx/output/queue/`.

## Generating your own valid_bb_files

The basic block files in the [valid_bb_files](./valid_bb_files) are generated with ghidra using the included [ghidra_get_bbs.py](./ghidra_get_bbs.py) script. To generate the basic block ground truth, load the ELF file of the firmware of your choice in ghidra, run the auto analysis, and then execute the script via ghidra's script manager.

## Replaying (SAFIRE, hal-fuzz, libafl)
Finally, you can use the provided `eval_bbs_halucinator.py` script to automatically replay inputs in HALucinator.  
The path to the queue is assumed to include a framework identifier, `libafl` or `hal-fuzz`, if none of those is found, SAFIREFUZZ is assumed.
HALucinator saves the set of unique basic blockes reached during the execution of an input in a `unique_bbs.out` file.  

Subsequently, we filter the basic blocks based on a `valid_bbs` list.
This is done to account for differences in block counting.
We count basic blocks based on Ghidraâ€™s _SimpleBlockModel_, i.e., we first import the firmware binaries in Ghidra to generate list of valid basic block addresses.  
We provide such lists for the evaluated targets in `./valid_bb_files`.

Replay the queue as follows:  
First, make sure you are in the HALucinator virtualenv:
```
source ~/.virtualenvs/halfuzz/bin/activate
```

Then, apply the patches enabling coverage collection during execution of a firmware target:
```
cd ../01_fuzzing/hal-fuzz
git apply --reject --whitespace=fix ../../02_coverage_collection/hal-fuzz_cov-col_patch.diff
```
Finally, run the provided script:
```
python3 eval_bbs_halucinator.py ./safirefuzz_example_output/wycinwyc valid_bb_files/wycinwyc.elf_bbs.txt safire_wycinwyc.data
```

We attach the automation scripts we used to evaluate all inputs generated during our experiments for reference.
As such, they are not expected to work out-of-the box and may be adjusted to work on your system.

## Replay (fuzzware)

Fuzzware inputs do not follow the same input formats as our different hal-based fuzzers.
Hence, for replaying these inputs (and collecting coverage), a different approach than above is required.

To replay the inputs and generate the statistics, please use the according genstats scripts: `fuzzware_genstats_with_hal.sh` and `fuzzware_genstats_without_hal.sh` . 
While the first one performs normal replay of the test cases, the second one excludes all coverage in hal functions. The entry points of these functions are provided in the different files in the [halhooks](./halhooks) subdirectory.

```shell
./fuzzware_genstats_with_hal.sh
./fuzzware_genstats_without_hal.sh
```

Note that coverage collection can take a while. By default, our scripts replay test cases with 5 instances in parallel. This can be changed by adjusting the $N_PARALLEL_JOBS variable in the two scripts.

After their completion, two new directory with the data should've been created: `fuzzware_hal_data` and `fuzzware_nohal_data`.




